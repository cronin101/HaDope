\section{Motivation}

The motivation for providing a high level framework for fast, parallel computation is to enable traditionally slow dynamic languages to be a powerful tool for scientific investigation on large data-sets.

Interpreted languages that can modify code at runtime are a powerful tool for creative experimentation as the user can modify the calculations being performed and instantly see the effect that this has on the results set. By allowing them to rival or exceed the computational power available in compiled languages using PThreads, a computer scientist can benefit from the ability to test hypotheses at runtime without suffering a noticeable performance penalty.

\section{Goals}

The project has a series of goals, selected after studying previous work in the field and evaluating what is missing from previous solutions.

\begin{description}
  \item[Production of a Framework]
  The final output goal of the project is to create a feature-rich platform for accelerating MapReduce and Functional Programming primitives via OpenCL co-processing.

  The successful completion of this goal will be demonstrated by the framework's abilities to handle a variety of tasks in a manner that is quicker or as quick as existing solutions, without sacrificing ease-of-use.

  The project currently focuses on fulfilling the feature-rich aspect of this goal. This is to avoid premature optimisation and allow features to have test-coverage and benchmark results before changes are made.
\end{description}

In addition to the major goal of producing a framework, the following sub-goals will influence the project's direction:

\begin{description}
  \item[Availability on a wide variety of platforms]
  The resulting framework should be available for use on many different systems. The project aims to provide a shortcut to high-throughput data-processing. It would be adverse to this goal if the shortcut was only available to a small subset of experimental set-ups.

  The project currently achieves a wide spread of compatible platforms by using OpenCL instead of CUDA for GPGPU interaction.

  The Ruby library associated with the project is simple to deploy on a system as the code can be cloned from a git repository and then native extensions built and linked via the project's Makefile. In future it will be possible to package the code and distribute it via a channel such as \emph{RubyGems}\cite{rubygems} to automate the download, building and linking process even further and to provide ease of updating.

  \item[Increasing data-processing throughput]
  The magnitude of improvement depends on the success of iterative optimisation of the framework. It is important to discover the disadvantages faced when offloading computation to co-processors, such as increased latency, so that the effects can be avoided. By allowing the framework to switch between multiple levels of acceleration by using heuristics may provide the benefit allowing operations with disadvantages to be avoided when the benefit is not worth it.

  \item[Providing re-usable components]
  Functional Programming coding styles often encourage the composition of common functions to implement more complicated operations. By building commonly used primitives into the framework, the code-base can take advantage of the reappearance of certain algorithms. For example, the prefix sum algorithm is used for both folding and calculating offsets for scattered writes. Scattered writes are useful for writing MapReduce values into buckets, and folding is often used in Reduce tasks. Exposing optimised low-level functions that are needed by a variety of tasks should reduce the amount of work that is needed to be done to improve the functionality of the project.

\end{description}

