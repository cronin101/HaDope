\lstset{
  language=Ruby,
  frame=single,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  identifierstyle=\ttfamily,
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941}
}
\begin{figure*}
\begin{lstlisting}
require 'hadope'

GPU = HaDope::GPU.get
 
nums = (1...1000000).to_a
 
# Device is async loaded with ints at point of load_int
# (This can't be optimised)
GPU.load_ints(nums)
# Futher method calls push tasks onto list.
# When OpenclDevice#! is called, these are optimised
# and async dispatched in one thread.
GPU.lmap(x:'x + 1').lmap(y:'y + 10')
GPU.lfilter(n:'n > 500000').lfilter(n:'n % 4 == 0')
GPU.fold('+').!
 
other_result = some_time_consuming_function(nums)
 
# Output joins async dispatch thread and then outputs
# result of reading device buffer.
result = GPU.output
\end{lstlisting}
\caption{Co-processing integers in the background.}
\label{snippet}
\end{figure*}

\begin{figure*}
\begin{lstlisting}
before :all do
  FP = HaDope::Functional

  @input_array = (1..100).to_a
  HaDope::DataSet.create(name: :test_dataset,
                          type: :int,
                          data: @input_array)

  FP::Map.create(name: :test_task,
                  key: [:int, :i],
                  function: 'i++;')

  FP::Map.create(name: :inverse_test_task,
                  key: [:int, :i],
                  function: 'i--;')
end

it "allows a map function to be executed on all data" do
  device = HaDope::CPU.get
  device.load(:test_dataset).fp_map(:test_task)
  output_array = device.output
  ruby_map = @input_array.map { |i| i + 1 }
  output_array.should eql ruby_map
end
\end{lstlisting}
\caption{Example of named tasks for invocation. This is a reduced snippet from the framework's behavior test suite. This style of declaring tasks is overly verbose for use with simple Map and Filter functions but named tasks will be important for using the MapReduce workflow.}
\label{named-tasks}
\end{figure*}

\begin{figure*}
\begin{lstlisting}
HaDope::MapR::Splitter.create( name: :word_unit,
                              in_key: [:string, :s],
                              out_key: [:string, 's'],
                              out_value: '1')
 
HaDope::MapR::Reduce.create( name: :sum_word_units,
                             in_key [:string, :s],
                             out_key [:string, 's']
                             out_value: [:fold_bucket, '+'])
 
GPU.load_strings(text_path, [:split_at, ' '])
GPU.splitter(:word_unit).reduce(:sum_word_units).!
 
word_count = GPU.output_hash
#=> { "the" => 1, "input" => 1, "string" => 1 }
\end{lstlisting}
\caption{Fabricated idea of how syntax might work for MapReduce tasks.}
\label{mp-snippet}
\end{figure*}


