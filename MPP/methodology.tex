\section{Methodology}
My project's purpose is to present users of the framework with increased performance when performing parallelisable operations on an input dataset.
It has the secondary aim of being unobtrustive to the programmer who may not wish to be troubled by the theoretical issues involved when distributing work over many cores.

I will be interfacing with the OpenCL API using C to perform the underlying function calls that are required for my framework's feature-set.
Even though \emph{Phoenix++} is written in C++ and most OpenCL code-samples online are written in C++, I feel that C is the wisest choice for my low-level implementation. I hold this view as I feel that the lack of some abstraction features in C benefits code-clarity and I feel it will not be significantly harder to port other project's optimisations to a framework written it in.

Although I shall be using my constructed library of C code to provide the capabilities of my framework, I intend to link this library to higher level languages such as \emph{Ruby} and possibly \emph{Python} via native extensions. I intend to present the framework to these languages as I feel that ease of use will be greatly improved by the syntactic sugar present in such interpreted languages. I also feel that they greatly increase possibilities for rapid prototyping by concisely allowing changes to framework parameters to be specified.

I have experience in producing descriptive assertion tests in the \emph{Ruby} language. I will ensure that good test-coverage of the library's computations provides greater confidence in the correctness of my code's output each time that changes are made to the underlying framework and its higher level features. With a set of tests specifying correct outputs over sample computations; it is much easier to change the architecture when attempting optimisation, as you can assert that the resulting values are unchanged.

Finally I feel that providing access to high-performance computation on data-sets via low-level extensions is advantageous to such languages as they often suffer compared to less syntactically-expressive languages when operating on basic types. By providing a simple method for performing low-level calculations, significant improvements to some use-cases could be provided.

The testing of OpenCL interaction will be performed on a variety of devices throughout it's development, ranging from a laptop's \emph{HD4000} integrated GPU to a high-end GPU in a current generation desktop machine. This makes it possible to investigate how optimisations affect differing architectures and hints at which benefits can be shared throughout all devices.
